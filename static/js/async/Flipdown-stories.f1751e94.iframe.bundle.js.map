{"version":3,"file":"static/js/async/Flipdown-stories.f1751e94.iframe.bundle.js","sources":["webpack://react-flipdown/./src/Rotor.tsx","webpack://react-flipdown/./src/RotorGroup.tsx","webpack://react-flipdown/./src/Flipdown.tsx"],"sourcesContent":["import React, {startTransition, useEffect, useRef} from \"react\";\nimport styled, {css} from \"styled-components\";\nimport {useFirstRender} from \"./useFirstRender\";\n\nconst MILLISECONDS_IN_SECOND = 1000;\nconst DURATION_ANIMATION_FLIP_IN_MS = 500;\nconst OFFSET_ANIMATION_FLIP_OUT_MS = 300;\n\nconst PreferColorScheme = css`\n    color: light-dark(#FFFFFF, #222222);\n    background-color: light-dark(#202020, #DDDDDD);\n`\n\nconst PreferColorSchemeVariant = css`\n    color: light-dark(#EFEFEF, #333333);\n    background-color: light-dark(#202020, #EEEEEE);\n`\n\nconst RotorContainer = styled.div`\n    position: relative;\n    float: left;\n    width: 50px;\n    height: 80px;\n    margin: 0 5px 0 0;\n    border-radius: 4px;\n    font-size: 4rem;\n    text-align: center;\n    perspective: 200px;\n    color: light-dark(#FFFFFF, #222222);\n    background-color: light-dark(#202020, #DDDDDD);\n    \n    &:last-child {\n        margin-right: 0;\n    }\n    \n    &:after {\n        content: '';\n        z-index: 2;\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 50px;\n        height: 40px;\n        border-radius: 0 0 4px 4px;\n        border-top: solid 1px light-dark(#151515, #222222);\n    }\n`\n\nconst RotorTopBottomView = styled.div`\n    overflow: hidden;\n    position: absolute;\n    width: 50px;\n    height: 40px;\n`\n\nconst RotorTop = styled(RotorTopBottomView)`\n    line-height: 80px;\n    border-radius: 4px 4px 0 0;\n\n    ${PreferColorScheme}\n`\n\nconst RotorBottom = styled(RotorTopBottomView)`\n    bottom: 0;\n    line-height: 0;\n    border-radius: 0 0 4px 4px;\n\n    ${PreferColorSchemeVariant}\n`\n\nconst RotorLeaf = styled.div`\n    z-index: 1;\n    position: absolute;\n    width: 50px;\n    height: 80px;\n    transform-style: preserve-3d;\n    \n    \n    &.flipped {\n        transform: rotateX(-180deg);\n        transition: all ${DURATION_ANIMATION_FLIP_IN_MS / MILLISECONDS_IN_SECOND}s ease-in-out;\n    }\n`\n\nconst RotorLeafView = styled.figure`\n    overflow: hidden;\n    position: absolute;\n    width: 50px;\n    height: 40px;\n    margin: 0;\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n`\n\nconst RotorLeafRear = styled(RotorLeafView)`\n    line-height: 0;\n    border-radius: 0 0 4px 4px;\n    transform: rotateX(-180deg);\n\n    ${PreferColorSchemeVariant}\n`\n\nconst RotorLeafFront = styled(RotorLeafView)`\n    line-height: 80px;\n    border-radius: 4px 4px 0 0;\n\n    ${PreferColorScheme}\n`\n\ntype Props = {\n    value: React.ReactNode;\n    prevValue: React.ReactNode,\n}\n\nexport function Rotor({value, prevValue}: Props) {\n    const rotorLeafRef = useRef<HTMLDivElement>(null);\n    const isFirstRender = useFirstRender();\n\n    const [currentValue, setCurrentValue] = React.useState(value);\n    const [previousValue, setPreviousValue] = React.useState(prevValue);\n\n    useEffect(() => {\n        if (rotorLeafRef.current && !isFirstRender) {\n            // Animate the flipping transition\n            rotorLeafRef.current.classList.remove(\"flipped\");\n            setTimeout(() => {\n                rotorLeafRef.current?.classList.add(\"flipped\");\n                setCurrentValue(value);\n            }, DURATION_ANIMATION_FLIP_IN_MS);\n\n            setTimeout(() => {\n                setPreviousValue(prevValue);\n            }, DURATION_ANIMATION_FLIP_IN_MS + OFFSET_ANIMATION_FLIP_OUT_MS);\n        }\n    }, [value, prevValue]);\n\n    return (\n        <RotorContainer>\n            <RotorLeaf ref={rotorLeafRef}>\n                <RotorLeafRear>\n                    {currentValue}\n                </RotorLeafRear>\n\n                <RotorLeafFront>\n                    {previousValue}\n                </RotorLeafFront>\n            </RotorLeaf>\n\n            <RotorTop>\n                {currentValue}\n            </RotorTop>\n\n            <RotorBottom>\n                {previousValue}\n            </RotorBottom>\n        </RotorContainer>\n    )\n}\n","import {Rotor} from \"./Rotor\";\nimport {useMemo} from \"react\";\nimport styled, {css} from \"styled-components\";\n\nconst FlexContainer = styled.div`\n    display: flex;\n    justify-content: center;\n    column-gap: 0.3rem;\n`\n\nconst Point = css`\n    content: '';\n    position: absolute;\n    left: 115px;\n    width: 10px;\n    height: 10px;\n    border-radius: 50%;\n`\n\nconst SeparatorPoints = css`\n    &:nth-child(n+2):nth-child(-n+3):before {\n        ${Point};\n        bottom: 20px;\n        background-color: light-dark(#151515, #DDDDDD);\n    }\n\n    &:nth-child(n+2):nth-child(-n+3):after {\n        ${Point};\n        bottom: 50px;\n        background-color: light-dark(#151515, #DDDDDD);\n    }\n`\n\ntype RotorGroupContainerProps = {\n    hiddenSeparators?: boolean,\n}\n\nconst RotorGroupContainer = styled.div<RotorGroupContainerProps>`\n    position: relative;\n    float: left;\n    padding-right: 30px;\n\n    &:last-child {\n        padding-right: 0;\n    }\n\n    ${props => props.hiddenSeparators ? null : SeparatorPoints}\n`\n\ntype RotorGroupHeadingProps = {\n    title: string,\n    hidden?: boolean,\n}\n\nconst RotorGroupHeading = styled.div<RotorGroupHeadingProps>`\n    &:before {\n        display: ${props => props.hidden ? 'none' : 'block'};\n        height: 30px;\n        line-height: 30px;\n        text-align: center;\n    }\n\n    &:before {\n        color: light-dark(#000000, #EEEEEE);\n        content: '${props => props.title}';\n    }\n`\n\ntype Props = {\n    title: string;\n    value: {\n        current: number,\n        previous: number,\n    };\n    showLabels?: boolean,\n    showSeparators?: boolean,\n}\n\nexport function RotorGroup({title, value, showLabels = true, showSeparators = true}: Props) {\n    const [slot1, slot2] = useMemo(() => String(value.current).padStart(2, \"0\").split(''), [value.current])\n    const [prev1, prev2] = useMemo(() => String(value.previous).padStart(2, \"0\").split(''), [value.previous])\n\n    return (\n        <RotorGroupContainer hiddenSeparators={!showSeparators}>\n            <RotorGroupHeading title={title} hidden={!showLabels}/>\n            <FlexContainer>\n                <Rotor value={slot1} prevValue={prev1}/>\n                <Rotor value={slot2} prevValue={prev2}/>\n            </FlexContainer>\n        </RotorGroupContainer>\n    )\n}","import {RotorGroup} from \"./RotorGroup\";\nimport {useCallback, useEffect, useMemo, useState} from \"react\";\nimport styled from \"styled-components\";\nimport {useFirstRender} from \"./useFirstRender\";\n\nconst ONE_SECOND_IN_MS = 1000;\n\nconst MAXIMUM_OF_DAY = 365;\nconst MAXIMUM_OF_HOUR = 24;\nconst MAXIMUM_OF_MINUTE = 60;\nconst MAXIMUM_OF_SECOND = 60;\n\nconst clampDay = (value: number) => {\n    if (value >= MAXIMUM_OF_DAY) return MAXIMUM_OF_DAY;\n    if (value < 0) return 0;\n    return value;\n}\n\nconst clampHour = (value: number) => {\n    if (value >= MAXIMUM_OF_HOUR) return MAXIMUM_OF_HOUR;\n    if (value < 0) return 0;\n    return value;\n}\n\nconst clampMinute = (value: number) => {\n    if (value >= MAXIMUM_OF_MINUTE) return MAXIMUM_OF_MINUTE;\n    if (value < 0) return 0;\n    return value;\n}\n\nconst clamSecond = (value: number) => {\n    if (value >= MAXIMUM_OF_SECOND) return MAXIMUM_OF_SECOND;\n    if (value < 0) return 0;\n    return value;\n}\n\nconst getCountdown = (epoch: number, isFirstRender: boolean) => {\n    // Get time now\n    const now = new Date().getTime() / 1000;\n\n    // Between now and epoch\n    let diff = epoch - now <= 0 ? 0 : epoch - now;\n\n    // Days remaining\n    const days = Math.floor(diff / 86400);\n    diff -= days * 86400;\n\n    // Hours remaining\n    const hours = Math.floor(diff / 3600);\n    diff -= hours * 3600;\n\n    // Minutes remaining\n    const minutes = Math.floor(diff / 60);\n    diff -= minutes * 60;\n\n    // Seconds remaining\n    const seconds = Math.floor(diff);\n\n    return {\n        days: {\n            current: days,\n            previous: isFirstRender ? days : clampDay(days - 1),\n        },\n        hours: {\n            current: hours,\n            previous: isFirstRender ? hours : clampHour(hours - 1),\n        },\n        minutes: {\n            current: minutes,\n            previous: isFirstRender ? minutes : clampMinute(minutes - 1),\n        },\n        seconds: {\n            current: seconds,\n            previous: isFirstRender ? seconds : clamSecond(seconds - 1),\n        },\n    }\n}\n\nconst Container = styled.div`\n    display: flex;\n    column-gap: 1.5rem;\n    justify-content: center;\n    overflow: visible;\n    font-family: sans-serif;\n    font-weight: bold;\n\n    @media (prefers-color-scheme: dark) {\n        & {\n            color-scheme: dark;\n        }\n    }\n\n    @media (prefers-color-scheme: light) {\n        & {\n            color-scheme: light;\n        }\n    }\n`\n\nexport type Props = {\n    epoch: number;\n    ifEnded?: () => void;\n    labels?: {\n        days: string,\n        hours: string,\n        minutes: string,\n        seconds: string,\n    },\n    showLabels?: boolean,\n    showSeparators?: boolean,\n}\n\nexport function Flipdown({epoch, ifEnded, ...props}: Props) {\n    const isFirstRender = useFirstRender();\n\n    const [countdownEnded, setCountdownEnded] = useState<boolean>(false);\n    const [callbackCalled, setCallbackCalled] = useState<boolean>(false);\n    const [countdown, setCountdown] = useState(getCountdown(epoch, isFirstRender));\n\n    const labels = useMemo(() => ({\n        days: props.labels?.days || \"Days\",\n        hours: props.labels?.hours || \"Hours\",\n        minutes: props.labels?.minutes || \"Minutes\",\n        seconds: props.labels?.seconds || \"Seconds\",\n    }), [props.labels])\n\n    // Has the countdown ended?\n    const hasCountdownEnded = useCallback(() => {\n        // Avoid recalculate if ended\n        if (countdownEnded) return true;\n\n        // Countdown has ended\n        if (epoch - new Date().getTime() / 1000 <= 0) {\n            setCountdownEnded(true);\n\n            // Fire the ifEnded callback once if it was set\n            if (ifEnded && !callbackCalled) {\n                // Call ifEnded callback\n                ifEnded();\n                setCallbackCalled(true);\n            }\n\n            return true;\n        }\n        // Countdown has not ended\n        return false;\n    }, [])\n\n    // Calculate current tick\n    useEffect(() => {\n        const interval = setInterval(() => {\n            // Has the countdown ended?\n            hasCountdownEnded();\n            // Trigger the refresh of UI\n            setCountdown(getCountdown(epoch, isFirstRender));\n        }, ONE_SECOND_IN_MS)\n\n        return () => clearInterval(interval);\n    }, []);\n\n    return (\n        <Container>\n            <RotorGroup\n                title={labels.days}\n                value={countdown.days}\n                showLabels={props.showLabels}\n                showSeparators={props.showSeparators}\n            />\n            <RotorGroup\n                title={labels.hours}\n                value={countdown.hours}\n                showLabels={props.showLabels}\n                showSeparators={props.showSeparators}\n            />\n            <RotorGroup\n                title={labels.minutes}\n                value={countdown.minutes}\n                showLabels={props.showLabels}\n                showSeparators={props.showSeparators}\n            />\n            <RotorGroup\n                title={labels.seconds}\n                value={countdown.seconds}\n                showLabels={props.showLabels}\n                showSeparators={props.showSeparators}\n            />\n        </Container>\n    )\n}"],"names":[],"mappings":";;;AAWA;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;;;;AAOA;;;;AAMA;AACA;;;;;AAOA;AACA;;;;;;;;;;AAYA;;AAEA;;;;;;;;AAUA;;;;;AAOA;AACA;;;;AAMA;AACA;;;;ACnGA;;;;;;;AASA;;AAIA;;;;;;AAMA;;;;AAIA;;;;;;;;;AAeA;AACA;;AASA;;;;;;;;AAQA;;AAEA;;;;;;;;;;;;;;;;;;;AC+BA"}